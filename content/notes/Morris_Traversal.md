---
title: 'Morris Traversal' # <--- 修改这一行
date: 2025-09-03T19:24:33+08:00
draft: false
location: ""
---

### 莫里斯遍历 - 实例走查

我们将使用下面的树来进行中序遍历。遍历的结果应该是 `[1, 2, 3, 4, 6]`。

**初始状态:**
* `current` 指向根节点 `4`。
* `result` (结果数组) 为 `[]`。

 4              <-- current
 / \\
2   6
/\\
1   3


---

#### 第 1 步

* **`current` = 4**
* **判断**: `current` (4) 有左孩子 `2`。
* **动作**:
    1.  找到 `current` (4) 的左子树 (`2` 为根) 的最右节点。这个节点是 `3`。
    2.  `3` 的右指针是 `nullptr`。
    3.  **建立线索**: 将 `3` 的右指针指向 `current` (4)。
    4.  `current` 向左移动：`current = current->left` (移向 `2`)。

* **树的状态**:
  4
 / \\
2   6
/
1   3 --+
^   |
|___|  (线索指向 4)

* **`result`: `[]`**

---

#### 第 2 步

* **`current` = 2**
* **判断**: `current` (2) 有左孩子 `1`。
* **动作**:
    1.  找到 `current` (2) 的左子树 (`1` 为根) 的最右节点。这个节点就是 `1` 本身。
    2.  `1` 的右指针是 `nullptr`。
    3.  **建立线索**: 将 `1` 的右指针指向 `current` (2)。
    4.  `current` 向左移动：`current = current->left` (移向 `1`)。

* **树的状态**:
  4
 / \
2   6
/

1   3 --+
^ \     |
|  +----|--(线索指向 2)
|_______|  (线索指向 4)

* **`result`: `[]`**

---

#### 第 3 步

* **`current` = 1**
* **判断**: `current` (1) **没有**左孩子。
* **动作**:
    1.  **访问 `1`**。
    2.  `current` 向右移动：`current = current->right` (根据我们建立的线索，它会移向 `2`)。

* **`result`: `[1]`**

---

#### 第 4 步

* **`current` = 2**
* **判断**: `current` (2) 有左孩子 `1`。
* **动作**:
    1.  再次找到 `current` (2) 的左子树的最右节点，还是 `1`。
    2.  这一次，我们发现 `1` 的右指针指向 `current` (2)，说明我们已经处理完 `current` 的左子树了。
    3.  **访问 `2`**。
    4.  **断开线索**: 将 `1` 的右指针恢复为 `nullptr`。
    5.  `current` 向右移动：`current = current->right` (移向 `3`)。

* **树的状态 (1->2 的线索已断开)**:
  4
 / \\
2   6
/
1   3 --+
^   |
|___| (线索指向 4)

* **`result`: `[1, 2]`**

---

#### 第 5 步

* **`current` = 3**
* **判断**: `current` (3) **没有**左孩子。
* **动作**:
    1.  **访问 `3`**。
    2.  `current` 向右移动：`current = current->right` (根据我们建立的线索，它会移向 `4`)。

* **`result`: `[1, 2, 3]`**

---

#### 第 6 步

* **`current` = 4**
* **判断**: `current` (4) 有左孩子 `2`。
* **动作**:
    1.  再次找到 `current` (4) 的左子树的最右节点，还是 `3`。
    2.  我们发现 `3` 的右指针指向 `current` (4)，说明我们已经处理完 `current` 的左子树了。
    3.  **访问 `4`**。
    4.  **断开线索**: 将 `3` 的右指针恢复为 `nullptr`。
    5.  `current` 向右移动：`current = current->right` (移向 `6`)。

* **树的状态 (完全恢复)**:
  4
 / \\
2   6
/
1   3

* **`result`: `[1, 2, 3, 4]`**

---

#### 第 7 步

* **`current` = 6**
* **判断**: `current` (6) **没有**左孩子。
* **动作**:
    1.  **访问 `6`**。
    2.  `current` 向右移动：`current = current->right` (移向 `nullptr`)。

* **`result`: `[1, 2, 3, 4, 6]`**

---

#### 结束

* **`current` = nullptr**
* **判断**: 循环结束。

最终，我们得到了正确的中序遍历结果 `[1, 2, 3, 4, 6]`，并且树的结构也完全恢复到了初始状态。

希望这个一步步的分解能帮助你理解莫里斯遍历的工作流程！