---
date: "2025-09-24T16:40:47+08:00"
draft: true
tags: ["", ""]
title: "数据包发送" # <--- 修改这一行
summary: "在这里写下您的文章摘要..."
---

着重理解一下数据传输过程中`datapacker_cfar_filtered`和函数` packet_wrap`里面涉及到了非常多的指针相关知识。

```cpp
/**
 * @brief 生成point_clouds_filtered数据包
 * @param buffer       数据包缓冲区
 * @param buffer_size  缓冲区大小（字节）
 * @param frameidx     帧ID
 * @param pcluster     point_clouds_filtered信息
 * @return 0：成功，其他：失败
 *
 */
static inline size_t packet_make_cfar_filtered(void *buffer, uint32_t buffer_size,uint32_t frameidx, const cfar2d_result_t *result)
{
    void *data = packet_data(buffer);
/*其中：#define packet_data(buffer) (((datapacket_wrapper_t *)buffer)->data)
typedef struct {
    int8_t head[16];
    uint16_t softwareID;
    uint16_t hardwareID;
    uint8_t unused[23];
    uint8_t dataType;
    uint32_t idxFrame;
    uint32_t dataSize;
    uint8_t data[4];
} __attribute__((packed)) datapacket_wrapper_t;
*/

    size_t size;

    size = datapacker_cfar_filtered(data, buffer_size - data_offset, result);
    size = packet_wrap(buffer, buffer_size, frameidx, PACKET_TYPE_CfarFiltered, data, size);
    return size;
}
// 其中：
size_t datapacker_cfar_filtered(void *buffer, size_t buffer_size, const cfar2d_result_t *result)
{
    typedef struct {
        int16_t dis;
        int16_t vec;
        int32_t amp;
        int32_t snr;
    } __attribute__((packed)) datapacker_clouds_filtered_t;

    datapacker_clouds_filtered_t *pack = (datapacker_clouds_filtered_t *)buffer;

    size_t ncloufil = result->numPoint;
    //这一行代码获取的是**“点的数量”**，也就是“结构体的个数”。假设在某一帧，雷达检测到了 3 个点，那么 ncloufil 的值就是 3

    size_t packsize;

    packsize = ncloufil * sizeof(datapacker_clouds_filtered_t);
    //存储所有结构体所需要的总字节数。其中sizeof(datapacker_clouds_filtered_t)是单个结构体占用的字节数:12个字节
    ASSERT(packsize <= buffer_size);
    for (size_t cnt = 0; cnt < ncloufil; cnt++) {
        pack[cnt].dis = result->point[cnt].idx0;
        pack[cnt].vec = result->point[cnt].idx1;
        pack[cnt].amp = result->point[cnt].amp;
        pack[cnt].snr = result->point[cnt].snr;
    }
    return packsize;
}

/**
 * @brief  将雷达数据封装成数据包并推送到串口缓冲区
 * @param  buffer       数据包缓冲区
 * @param  buffer_size  缓冲区大小（字节）
 * @param  frameidx     帧ID
 * @param  type         数据类型，0：dsraw，1：1dfft，2：2dfft
 * @param  data         数据地址
 * @param  data_size    数据长度
 * @return 0：成功，其他：失败
 */
 //接收这个 DATA 字节流，并为其加上 HEAD、INFO (包含帧ID、包类型、数据长度) 和可能的 TAIL (校验和)，最终组成一个完整的可供发送的数据包。
size_t packet_wrap(void *buffer, uint32_t buffer_size, uint32_t frameidx, packet_type_e type,
                   void *data, uint32_t data_size)
{
    // 总长度 = 结构体头部 + 数据长度 + CRC
    size_t totalLen = data_offset + data_size + sizeof(uint32_t);
    //其中：#define data_offset         offsetof(datapacket_wrapper_t, data)
    //data_offset:计算结构体成员相对于结构体起始地址的偏移量，按照传输协议，data在偏移54+N，故offsetof(datapacket_wrapper_t, data)=54+N
    datapacket_wrapper_t *pkt = (datapacket_wrapper_t *)buffer;

    // 边界检查
    ASSERT(buffer != NULL);
    ASSERT(data != NULL);
    ASSERT(buffer_size >= totalLen); // 缓冲区不能小于需要的总长度
    ASSERT(sizeof(pkt->head) >= sizeof(DATA_PACKET_HEADER) - 1);

    // 填充固定头部
    memcpy(pkt->head, DATA_PACKET_HEADER, sizeof(DATA_PACKET_HEADER));
/* void *memcpy(void *dest, const void *src, size_t n);
dest：目标内存的起始地址（复制到这里）
src：源内存的起始地址（从这里复制）
n：要拷贝的字节数
内存区域不能重叠
- 如果 src 和 dest 有重叠，用 memmove，否则结果可能出错。
- 例如：memcpy(arr+1, arr, 5) 就有重叠风险。
 */
    pkt->softwareID = 0x0101; // 软件版本为 0x01
    pkt->hardwareID = 0x0842; // 硬件版本号
    pkt->dataType = type;
    pkt->idxFrame = frameidx;
    pkt->dataSize = data_size;

    // 拷贝用户数据（防止地址重合）
    if (pkt->data != (uint8_t *)data) {
        memcpy(pkt->data, data, data_size);
    }

    // 计算 CRC（仅对前 baseLen + DLen 字节）
    uint8_t *byteBuf = (uint8_t *)buffer;
    /* buffer之前是一个void类型
    void *buffer;buffer + 1; -> 编译器会尝试计算 buffer的地址 + 1 * sizeof(void)。
    但 void 是一个“无类型”的类型，它没有定义的大小！sizeof(void) 是不合法的。
    比如int32_t *p; p + 1; -> 编译器会计算 p的地址 + 1 * sizeof(int32_t)，即地址前进 4 个字节。
    故需要：通过强制类型转换为 uint8_t * 赋予指针“意义”*/
    /*对于两个：datapacket_wrapper_t *pkt = (datapacket_wrapper_t *)buffer；
    uint8_t *byteBuf = (uint8_t *)buffer;
    我们可以创建任意多个、任意类型的指针,无论我们使用哪个指针去修改这块内存,我们改变的都是那块唯一的、客观存在的物理内存区域,因此，当我们换一个指针去查看这块内存时，看到的就是被其他指针修改后的最新状态
    */
    uint32_t crc = 0;
    for (uint32_t i = 0; i < data_offset + data_size; ++i) {
        crc += byteBuf[i];
    }

    // 添加 CRC 到数据末尾
    memcpy(byteBuf + data_offset + data_size, &crc, sizeof(uint32_t));
    //取出crc的内容，填到校验码的地方

    return totalLen;
}
```
