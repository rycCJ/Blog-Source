
[{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/tags/recursion/","section":"Tags","summary":"","title":"Recursion","type":"tags"},{"content":"B站“灵茶山艾府“的解释\n递归的核心思想：不是人肉压栈，而是“甩锅” #\r初学者的困境：人肉模拟调用栈\r当递归层数很少时，比如三层，你还能模拟：main 调用 A，A 调用 B，B 调用 C。C 返回给 B，B 返回给 A，A 返回给 main。但当层数一多，你的大脑就会像计算机内存溢出一样，难以追踪。\n正确的递归思维方式是“信任”或者叫“信念之跃”（Leap of Faith）。\r你只需要关注两件事：\n1.终止条件（Base Case）：什么时候问题小到可以直接解决，不需要再“甩锅”给下一层了？\n2.递归关系（Recursive Relation）：如何把当前问题，分解成一个或多个规模更小的同类子问题，并假设（信任）下一层调用能完美解决这些子问题。然后，你只需要思考如何利用子问题的解来组合成当前问题的解。\n**你不需要去想下一层是怎么实现的，你只要相信它能给你正确的结果就行了。**就像调用一个库函数sort()，你不会去关心它内部是快排还是归并.\n把递归函数本身，也当成一个黑盒的、可信赖的库函数来调用。\n以二叉树为例 #\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // 定义二叉树节点 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; /* 我们来定义函数 maxDepth(root) 它的功能是：接收一个树的根节点，返回这棵树的最大深度。 */ int maxDepth(TreeNode* root) { // 1. 终止条件 (Base Case) // 如果这个节点是空的（比如一个叶子节点的子节点）， // 那么它构成的树深度就是 0。这是最简单、可以直接回答的问题。 if (root == nullptr) { return 0; } // 2. 递归关系 (Recursive Relation) // 对于任何一个非空的节点 root，它的最大深度是多少？ // 我们可以把它分解成两个子问题： // - 左子树的最大深度是多少？ // - 右子树的最大深度是多少？ // 这两个子问题的规模都比当前问题（整棵树的深度）要小。 // 而且它们是同类问题：都是“计算一棵树的最大深度”。 // 所以，我们可以“甩锅”了！ // 我假设 maxDepth() 这个函数已经能完美工作了（信念之跃）。 // 我把它当成一个已知的、可靠的工具来调用。 // 我“相信”下面这行代码能正确计算出左子树的深度。 // 我不去想 aleftDepth 是怎么一步步算出来的。 int leftDepth = maxDepth(root-\u0026gt;left); // 我同样“相信”这行代码能正确计算出右子树的深度。 int rightDepth = maxDepth(root-\u0026gt;right); // 3. 组合子问题的解 // 现在，我已经拿到了两个子问题的答案：leftDepth 和 rightDepth。 // 如何用这两个答案来解决我当前的问题（以 root 为根的树的深度）？ // 很显然，整棵树的深度 = 左右子树深度的较大者 + 1 (当前这一层) return std::max(leftDepth, rightDepth) + 1; } int main() { /* 构造一棵树: 3 / \\ 9 20 / \\ 15 7 */ TreeNode* root = new TreeNode(3); root-\u0026gt;left = new TreeNode(9); root-\u0026gt;right = new TreeNode(20); root-\u0026gt;right-\u0026gt;left = new TreeNode(15); root-\u0026gt;right-\u0026gt;right = new TreeNode(7); std::cout \u0026lt;\u0026lt; \u0026#34;这棵树的最大深度是: \u0026#34; \u0026lt;\u0026lt; maxDepth(root) \u0026lt;\u0026lt; std::endl; // 应该输出 3 delete root-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;right; delete root-\u0026gt;right; delete root; return 0; } 如何正确思考 maxDepth(root) 的过程？\n1.我的目标：实现 maxDepth(root) 函数。\n2.第一步：找终止条件。 什么情况下最简单？树是空的！if (root == nullptr)，深度就是 0。搞定。\n3.第二步：找递归关系。 如果树不空，root 指向一个节点。这棵树的深度和它的左右孩子有什么关系？\n我需要知道左子树的深度。\n我需要知道右子树的深度。\n整棵树的深度就是 max(左深度, 右深度) + 1。\n4.第三步：写代码（信念之跃）。 如何获取左子树的深度？直接调用 maxDepth(root-\u0026gt;left)。相信它！ 不要去想它内部是怎么对 root-\u0026gt;left 的子节点进行递归的。就把它当成 int leftDepth = getLeftDepth() 这么一个普通的函数调用。\n如何获取右子树的深度？同理，调用 maxDepth(root-\u0026gt;right)。相信它！\n拿到 leftDepth 和 rightDepth 后，根据第二步的分析，return std::max(leftDepth, rightDepth) + 1;。\n整个思考过程，我们只关注“当前层”的逻辑。 我们把对子树的处理完全委托给了递归调用，我们是“管理者”，不是“微观执行者”。\n再举一例：二叉树的前序遍历 #\r前序遍历的顺序是：根 -\u0026gt; 左 -\u0026gt; 右。这个定义本身就充满了递归的味道\nvoid preOrderTraversal(TreeNode* root) { // 1. 终止条件 if (root == nullptr) { return; // 空树就直接返回，什么也不做 } // 2. 处理当前节点 (根) std::cout \u0026lt;\u0026lt; root-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 访问根节点 // 3. 递归处理左子树 (左) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个左子树 preOrderTraversal(root-\u0026gt;left); // 4. 递归处理右子树 (右) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个右子树 preOrderTraversal(root-\u0026gt;right); } 正确思考 preOrderTraversal：\n1.我的目标：按“根-左-右”的顺序打印树。\n2.终止条件：root 是 nullptr，没什么可打印的，直接 return。\n3.当前层的逻辑：如果 root 不是 nullptr，根据“根-左-右”的定义，我应该：\n先处理“根”：cout \u0026lt;\u0026lt; root-\u0026gt;val;\n然后处理“左”：怎么处理？这是一个规模更小的同类问题，直接调用 preOrderTraversal(root-\u0026gt;left); 来搞定整个左子树。相信它能行！\n最后处理“右”：同理，调用 preOrderTraversal(root-\u0026gt;right); 来搞定整个右子树。相信它也能行！\n代码和逻辑完全一一对应，清晰明了。 你根本不需要去想，调用 preOrderTraversal(root-\u0026gt;left)之后，它又会怎么打印，怎么调用它的左孩子和右孩子。你只要相信这个函数的功能定义是正确的，你调用它，它就能完成任务。\n总结与建议 #\r明确函数定义：在写递归函数之前，用一句话清晰地描述这个函数的功能。例如：“maxDepth(node)的功能是返回以 node 为根的子树的最大深度”。在后续的递归调用中，始终坚信你调用的就是这个已经实现的功能。\n只考虑当前层：你的所有逻辑都应该只围绕“当前节点”展开。你需要做什么？你需要从子问题的解中得到什么信息？你如何利用这些信息？\n找到终止条件：思考什么情况下问题规模最小，可以被直接解决，不再需要递归。这是递归的出口，没有它就会无限循环，导致“栈溢出”。\n信任递归调用：这是最关键的一步。当你对 function(sub_problem) 进行调用时，就把它当成一个已知的、正确的黑盒。你的任务不是去追踪它的执行，而是去使用它的返回结果。\n当你下次再遇到一个递归问题时，请抑制住你的大脑去模拟整个调用栈的冲动。强迫自己用上面的思维模式去思考，多练习几次，你会发现递归问题会变得异常清晰和简单。它是一种将复杂问题分解为简单、重复单元的强大思维工具。\n","date":"15 September 2025","externalUrl":null,"permalink":"/notes/recursive_relation/","section":"Notes","summary":"","title":"Recursive Relation","type":"notes"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/","section":"Welcome to My Blog","summary":"","title":"Welcome to My Blog","type":"page"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/conda/","section":"Tags","summary":"","title":"Conda","type":"tags"},{"content":"https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html\n创建环境 #\r创建一个新环境\nconda create -n \u0026lt;env-name\u0026gt; 创建环境并且下载指定包\nconda create -n myenvironment python numpy pandas\rconda create -n myenv scipy=0.17.3 //特定库版本 创建环境指定特定pyhton版本 conda create -n myenv python=3.9 conda create -n myenv python=3.9 特定pyhton版本和多个库 conda create -n myenv python=3.9 scipy=0.17.3 astroid babel\n查看所有环境 #\rconda info --envs\r例如：\rconda environments:\rbase /home/username/Anaconda3\rmyenvironment * /home/username/Anaconda3/envs/myenvironment 当前环境带*\n改变当前环境为默认的一个\nconda activate 下载库 #\r# via environment activation\rconda activate myenvironment\rconda install matplotlib\r# via command line option\rconda install --name myenvironment matplotlib If a package you want is located in another channel, such as conda-forge, you can manually specify the channel when installing the package:\nconda install conda-forge::numpy 更新Conda #\r查看Conda版本\nconda --version 更新到最新版本\nconda update conda ","date":"8 September 2025","externalUrl":null,"permalink":"/posts/conda_start/","section":"Posts","summary":"Conda使用","title":"Conda Start","type":"posts"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"\r莫里斯遍历 - 实例走查 #\r我们将使用下面的树来进行中序遍历。遍历的结果应该是 [1, 2, 3, 4, 6]。\n初始状态:\ncurrent 指向根节点 4。 result (结果数组) 为 []。 4 \u0026lt;\u0026ndash; current / \\ 2 6 /\\ 1 3\n第 1 步 #\rcurrent = 4\n判断: current (4) 有左孩子 2。\n动作:\n找到 current (4) 的左子树 (2 为根) 的最右节点。这个节点是 3。 3 的右指针是 nullptr。 建立线索: 将 3 的右指针指向 current (4)。 current 向左移动：current = current-\u0026gt;left (移向 2)。 树的状态: 4 / \\ 2 6 / 1 3 \u0026ndash;+ ^ | |___| (线索指向 4)\nresult: []\n第 2 步 #\rcurrent = 2\n判断: current (2) 有左孩子 1。\n动作:\n找到 current (2) 的左子树 (1 为根) 的最右节点。这个节点就是 1 本身。 1 的右指针是 nullptr。 建立线索: 将 1 的右指针指向 current (2)。 current 向左移动：current = current-\u0026gt;left (移向 1)。 树的状态: 4 / 2 6 /\n1 3 \u0026ndash;+ ^ \\ | | +\u0026mdash;-|\u0026ndash;(线索指向 2) |_______| (线索指向 4)\nresult: [] 第 3 步 #\rcurrent = 1\n判断: current (1) 没有左孩子。\n动作:\n访问 1。 current 向右移动：current = current-\u0026gt;right (根据我们建立的线索，它会移向 2)。 result: [1]\n第 4 步 #\rcurrent = 2\n判断: current (2) 有左孩子 1。\n动作:\n再次找到 current (2) 的左子树的最右节点，还是 1。 这一次，我们发现 1 的右指针指向 current (2)，说明我们已经处理完 current 的左子树了。 访问 2。 断开线索: 将 1 的右指针恢复为 nullptr。 current 向右移动：current = current-\u0026gt;right (移向 3)。 树的状态 (1-\u0026gt;2 的线索已断开): 4 / \\ 2 6 / 1 3 \u0026ndash;+ ^ | |___| (线索指向 4)\nresult: [1, 2]\n第 5 步 #\rcurrent = 3\n判断: current (3) 没有左孩子。\n动作:\n访问 3。 current 向右移动：current = current-\u0026gt;right (根据我们建立的线索，它会移向 4)。 result: [1, 2, 3]\n第 6 步 #\rcurrent = 4\n判断: current (4) 有左孩子 2。\n动作:\n再次找到 current (4) 的左子树的最右节点，还是 3。 我们发现 3 的右指针指向 current (4)，说明我们已经处理完 current 的左子树了。 访问 4。 断开线索: 将 3 的右指针恢复为 nullptr。 current 向右移动：current = current-\u0026gt;right (移向 6)。 树的状态 (完全恢复): 4 / \\ 2 6 / 1 3\nresult: [1, 2, 3, 4]\n第 7 步 #\rcurrent = 6\n判断: current (6) 没有左孩子。\n动作:\n访问 6。 current 向右移动：current = current-\u0026gt;right (移向 nullptr)。 result: [1, 2, 3, 4, 6]\n结束 #\rcurrent = nullptr 判断: 循环结束。 最终，我们得到了正确的中序遍历结果 [1, 2, 3, 4, 6]，并且树的结构也完全恢复到了初始状态。\n希望这个一步步的分解能帮助你理解莫里斯遍历的工作流程！\n","date":"3 September 2025","externalUrl":null,"permalink":"/notes/morris_traversal/","section":"Notes","summary":"","title":"Morris Traversal","type":"notes"},{"content":"步骤 1: 在 GitHub 上创建新的远程仓库 步骤 2: 在本地电脑上操作\n# 打开 Git Bash进入你的项目文件夹\rcd ~/Desktop/my-first-project\r# 初始化 Git 仓库:\rgit init\r#添加所有文件到暂存区:\rgit add .\r# 提交文件到本地仓库:\rgit commit -m \u0026#34;Initial commit\u0026#34;\r#重命名主分支为 main\rgit branch -m main\r# 关联本地仓库和远程仓库:\rgit remote add origin https://github.com/YourUsername/YourProjectName.git # 把下面的 URL 换成你自己的仓库 URL\r# 推送代码到 GitHub:\rgit push -u origin main ","date":"2 September 2025","externalUrl":null,"permalink":"/posts/a_folder_to_git/","section":"Posts","summary":"本地文件夹上传至GitHub","title":"A Folder to Git","type":"posts"},{"content":"","date":"2 September 2025","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"创建项目文件夹\n打开命令行工具（比如 CMD、PowerShell 或者 Windows Terminal），然后进入存放所有代码的目录（例如 D:\\projects）。\n# 1. 进入项目的父目录(请根据实际情况修改 \u0026#34;D:\\projects\u0026#34;)\rcd D:\\projects\r2. 创建新文件夹作为根目录\rmkdir my_new_project\r3. 进入这个新创建的文件夹\rcd my_new_project 创建虚拟环境\n# 确保在项目根目录下 (D:\\projects\\my_new_project)\r# -m venv 的意思是 \u0026#34;以模块(module)方式运行 venv\u0026#34;\r# 最后的 \u0026#34;venv\u0026#34; 是给虚拟环境文件夹取的名字\rpython -m venv venv\r# 执行完毕后，会发现项目文件夹里多出了一个名为 venv 的子文件夹。这里面包含了独立的 Python 解释器和未来将要安装的库。 激活虚拟环境\n# 在 Windows PowerShell 中，运行以下命令\r.\\venv\\Scripts\\activate 激活成功后，会看到命令行提示符的前面多了一个 (venv) 的标记，像这样：\r(venv) PS D:\\projects\\my_new_project\u0026gt; 这个 (venv) 标志非常重要，它告诉你当前终端已经处于激活的虚拟环境中。所有后续的 pip 安装和 python 命令都将只在这个环境内生效。\n# 在 VS Code 中打开项目,确保还在项目根目录下 (有 (venv) 标志),这个命令会用 VS Code 打开当前文件夹\rcode . 配置 VS Code 解释器\n1.当用 VS Code 打开带有 venv 文件夹的项目时，VS Code 通常会在右下角弹出一个提示：We noticed a new environment has been created. Do you want to select it for the workspace folder? (我们发现了一个新环境，您要为工作区选择它吗？)。\n请务必点击 Yes。\n2.如果 VS Code 没有自动提示，可以手动选择：\n按下 Ctrl+Shift+P 打开命令面板。\n输入并选择 Python: Select Interpreter (Python: 选择解释器)。\n在列表中，选择那个带有 (\u0026lsquo;venv\u0026rsquo;: venv) 标志或者路径中包含 .\\venv\\Scripts\\python.exe 的选项。\n安装项目所需的库\n现在，可以在 VS Code 的集成终端中（确保终端前面有 (venv) 标志）安装任何需要的第三方库了。\n完整的、专业的开发流程\n在项目开始时就创建.gitignore 文件，并加入 venv/\n在虚拟环境中安装项目所需的库（例如pip install pandas）\n每当安装或更新了重要的库之后，就更新 requirements.txt文件： pip freeze \u0026gt; requirements.txt\n将源代码、.gitignore 和更新后的 requirements.txt 一起提交到GitHub。\ngit add .\rgit commit -m \u0026#34;Add new feature and update dependencies\u0026#34;\rgit push 拿到项目后,只需要执行以下几步\n克隆仓库 git clone \u0026lt;your_repo_url\u0026gt;\rcd \u0026lt;your_repo_name\u0026gt; 创建并激活他们自己的venv python -m venv venv 在Windows上:\r.\\venv\\Scripts\\activate\r在macOS/Linux上:\rsource venv/bin/activate 根据依赖列表，一键安装所有库 pip install -r requirements.txt ","date":"11 August 2025","externalUrl":null,"permalink":"/posts/create_new_project/","section":"Posts","summary":"带虚拟环境的 Python 项目","title":"Create New Project","type":"posts"},{"content":"","date":"11 August 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"1.创建一篇新文章 打开Git Bash 终端，进入根目录d:/Blog\nhugo new content posts/hello-world.md\n告诉Hugo，在 content/posts/ 目录下，创建一个名为 hello-world.md 的新文章。\n2.编写文章内容\n打开VS Code，在 hello-world.md里面写内容 将draft：true改为draft：false 3.在本地预览效果\n回到Git Bash终端，运行： hugo server\n终端会启动一个本地服务器，并显示网址 http://localhost:1313/,打开网址浏览即可 预览完毕后，回到终端，按 Ctrl + C 组合键，停止本地服务器。 4.提交并推送到GitHub (自动发布)\n添加更改到暂存区 git add .\n提交更改到本地仓库 (创建一个新的提交记录) git commit -m \u0026ldquo;feat: Add my first post \u0026lsquo;Hello World\u0026rsquo;\u0026rdquo;\nfeat: 是一种规范的提交信息前缀，意思是“增加新功能”，这里指增加了新文章。\n写了一篇新文章？用 feat。\n修改了一篇文章的内容或错别字？用 docs。\n修正了一个导致网站显示不正常的Bug？用 fix。\n更新了 .gitignore 或者 deploy.yml？用 chore。\n推送到GitHub (这是触发自动部署的扳机) git push origin main\n5.检查线上部署\n打开浏览器，进入您之前创建的源码仓 (Blog-Source) 的GitHub页面。 点击页面上方的 “Actions” 选项卡。 您会看到一个新的工作流（Workflow）正在运行，它前面会有一个黄色的小圆圈。这就是GitHub在后台帮您生成和部署网站。 等待1-2分钟，当黄色圆圈变成绿色的对勾 (✓) 时，就代表您的网站已经部署成功了。 现在，请在浏览器中访问您的线上博客地址： https://\u0026lt;您的GitHub用户名\u0026gt;.github.io\n","date":"9 August 2025","externalUrl":null,"permalink":"/posts/publishing_process/","section":"Posts","summary":"","title":"Publishing_process 博客发布流程","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]