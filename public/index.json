
[{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"Learn Git Branching学习总结\n提交\r#\rgit commit git branch \u0026lt;name\u0026gt; //添加分支 git checkout \u0026lt;name\u0026gt; //切换到分支 git checkout -b bugFix //新建并且切换 合并分支\r#\r方法一：使用git merge合并两个分支 git checkout -b bugFix //新建并且切换\rgit commit\rgit checkout main\rgit commit //提交main\rgit merge bugFix //将bugFix合并进main 方法二：使用git rebase合并两个分支 git checkout -b bugFix //新建并且切换\rgit commit\rgit checkout main\rgit commit\rgit checkout bugFix\rgit rebase main Head\r#\r我们首先看一下 HEAD。 HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向\n相对引用 ^\r#\r使用^向上移动 1 个提交记录;使用~\u0026lt;num\u0026gt; 向上移动多个提交记录，如 ~3\n让分支指向另一个提交 例如 :\ngit checkout main^\rgit branch -f main HEAD~3\rgit branch -f three C2 //让three指向C2 会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。\n撤销变更\r#\rgit reset HEAD~1 //当前分支撤销到上一级，仅在本地\rgit revert C1 //当前分支添加一个新的分支，里面的操作可为撤销，可以远程\rgit revert C1 //撤销到 C1 整理提交记录\r#\rgit cherry-pick \u0026lt;提交号\u0026gt;... git cherry-pick C2 C4` 将 C2 C4（分支上的 指的是哈希值）复制到 main（当前分支）分支\rgit cherry-pick xx ` 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上 交互式的 rebase git rebase -i HEAD~4//对 HEAD~4 之后的提交修改顺序 创建标签\r#\rgit tag v1 C1\rgit tag v1 main~2(main 的上两级) //建立一个标签，指向提交记录 C1，表示这是我们 1.0 版本 git describe \\\u0026lt;ref\u0026gt;\n\u0026lt;ref\u0026gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（HEAD）。\n它输出的结果是这样的：\u0026lt;tag\u0026gt;_\u0026lt;numCommits\u0026gt;_g\u0026lt;hash\u0026gt;\ntag 表示的是离 ref 最近的标签， numCommits 是表示这个ref与tag相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。\n当 ref 提交记录上有某个标签时，则只输出标签名称\n两个 parent 节点\r#\r若有两个 parnet 节点，HEAD^ 代表第一个 parnet 节点，HEAD^2 代表另一个不近的节点。\ngit checkout HEAD^2 //去到当前分支的较远的 parent 节点\rgit branch bugWork main^^2^ //创建 bugWork 并且移动到 main 父节点的第二个父节点的父节点 偏离的提交历史\r#\r假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。\ngit fetch; //更新了本地仓库中的远程分支\rgit rebase o/main; //将我们的工作移动到最新的提交记录下\rgit push //推送到远程仓库 也可以使用 merge\ngit fetch; //更新了本地仓库中的远程分支\rgit merge o/main; //将合并了新变更到我们的本地分支（为了包含远程仓库的变更\rgit push //推送到远程仓库 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写\n远程服务器拒绝!(Remote Rejected)\r#\r远程服务器拒绝直接推送(push)提交到 main, 因为策略配置要求 pull requests 来提交更新.\n你应该按照流程,新建一个分支, 推送(push)这个分支并申请 pull request,但是你忘记并直接提交给了 main.现在你卡住并且无法推送你的更新\n新建一个分支 feature, 推送到远程服务器. 然后 reset 你的 main 分支和远程服务器保持一致, 否则下次你 pull 并且他人的提交和你冲突的时候就会有问题.\ngit branch -f main o/main\rgit checkout -b feature C2\rgit push origin feature 合并多个分支\r#\rgit fetch\rgit rebase o/main side1\rgit rebase side1 side2\rgit rebase side2 side3\rgit push ","date":"26 September 2025","externalUrl":null,"permalink":"/posts/git%E5%AD%A6%E4%B9%A0/","section":"Posts","summary":"Learn Git Branching学习总结","title":"Git学习","type":"posts"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/","section":"Welcome to My Blog","summary":"","title":"Welcome to My Blog","type":"page"},{"content":"着重理解一下数据传输过程中datapacker_cfar_filtered和函数 packet_wrap里面涉及到了非常多的指针相关知识。\n/** * @brief 生成point_clouds_filtered数据包 * @param buffer 数据包缓冲区 * @param buffer_size 缓冲区大小（字节） * @param frameidx 帧ID * @param pcluster point_clouds_filtered信息 * @return 0：成功，其他：失败 * */ static inline size_t packet_make_cfar_filtered(void *buffer, uint32_t buffer_size,uint32_t frameidx, const cfar2d_result_t *result) { void *data = packet_data(buffer); /*其中：#define packet_data(buffer) (((datapacket_wrapper_t *)buffer)-\u0026gt;data) typedef struct { int8_t head[16]; uint16_t softwareID; uint16_t hardwareID; uint8_t unused[23]; uint8_t dataType; uint32_t idxFrame; uint32_t dataSize; uint8_t data[4]; } __attribute__((packed)) datapacket_wrapper_t; */ size_t size; size = datapacker_cfar_filtered(data, buffer_size - data_offset, result); size = packet_wrap(buffer, buffer_size, frameidx, PACKET_TYPE_CfarFiltered, data, size); return size; } // 其中： size_t datapacker_cfar_filtered(void *buffer, size_t buffer_size, const cfar2d_result_t *result) { typedef struct { int16_t dis; int16_t vec; int32_t amp; int32_t snr; } __attribute__((packed)) datapacker_clouds_filtered_t; datapacker_clouds_filtered_t *pack = (datapacker_clouds_filtered_t *)buffer; size_t ncloufil = result-\u0026gt;numPoint; //这一行代码获取的是**“点的数量”**，也就是“结构体的个数”。假设在某一帧，雷达检测到了 3 个点，那么 ncloufil 的值就是 3 size_t packsize; packsize = ncloufil * sizeof(datapacker_clouds_filtered_t); //存储所有结构体所需要的总字节数。其中sizeof(datapacker_clouds_filtered_t)是单个结构体占用的字节数:12个字节 ASSERT(packsize \u0026lt;= buffer_size); for (size_t cnt = 0; cnt \u0026lt; ncloufil; cnt++) { pack[cnt].dis = result-\u0026gt;point[cnt].idx0; pack[cnt].vec = result-\u0026gt;point[cnt].idx1; pack[cnt].amp = result-\u0026gt;point[cnt].amp; pack[cnt].snr = result-\u0026gt;point[cnt].snr; } return packsize; } /** * @brief 将雷达数据封装成数据包并推送到串口缓冲区 * @param buffer 数据包缓冲区 * @param buffer_size 缓冲区大小（字节） * @param frameidx 帧ID * @param type 数据类型，0：dsraw，1：1dfft，2：2dfft * @param data 数据地址 * @param data_size 数据长度 * @return 0：成功，其他：失败 */ //接收这个 DATA 字节流，并为其加上 HEAD、INFO (包含帧ID、包类型、数据长度) 和可能的 TAIL (校验和)，最终组成一个完整的可供发送的数据包。 size_t packet_wrap(void *buffer, uint32_t buffer_size, uint32_t frameidx, packet_type_e type, void *data, uint32_t data_size) { // 总长度 = 结构体头部 + 数据长度 + CRC size_t totalLen = data_offset + data_size + sizeof(uint32_t); //其中：#define data_offset offsetof(datapacket_wrapper_t, data) //data_offset:计算结构体成员相对于结构体起始地址的偏移量，按照传输协议，data在偏移54+N，故offsetof(datapacket_wrapper_t, data)=54+N datapacket_wrapper_t *pkt = (datapacket_wrapper_t *)buffer; // 边界检查 ASSERT(buffer != NULL); ASSERT(data != NULL); ASSERT(buffer_size \u0026gt;= totalLen); // 缓冲区不能小于需要的总长度 ASSERT(sizeof(pkt-\u0026gt;head) \u0026gt;= sizeof(DATA_PACKET_HEADER) - 1); // 填充固定头部 memcpy(pkt-\u0026gt;head, DATA_PACKET_HEADER, sizeof(DATA_PACKET_HEADER)); /* void *memcpy(void *dest, const void *src, size_t n); dest：目标内存的起始地址（复制到这里） src：源内存的起始地址（从这里复制） n：要拷贝的字节数 内存区域不能重叠 - 如果 src 和 dest 有重叠，用 memmove，否则结果可能出错。 - 例如：memcpy(arr+1, arr, 5) 就有重叠风险。 */ pkt-\u0026gt;softwareID = 0x0101; // 软件版本为 0x01 pkt-\u0026gt;hardwareID = 0x0842; // 硬件版本号 pkt-\u0026gt;dataType = type; pkt-\u0026gt;idxFrame = frameidx; pkt-\u0026gt;dataSize = data_size; // 拷贝用户数据（防止地址重合） if (pkt-\u0026gt;data != (uint8_t *)data) { memcpy(pkt-\u0026gt;data, data, data_size); } // 计算 CRC（仅对前 baseLen + DLen 字节） uint8_t *byteBuf = (uint8_t *)buffer; /* buffer之前是一个void类型 void *buffer;buffer + 1; -\u0026gt; 编译器会尝试计算 buffer的地址 + 1 * sizeof(void)。 但 void 是一个“无类型”的类型，它没有定义的大小！sizeof(void) 是不合法的。 比如int32_t *p; p + 1; -\u0026gt; 编译器会计算 p的地址 + 1 * sizeof(int32_t)，即地址前进 4 个字节。 故需要：通过强制类型转换为 uint8_t * 赋予指针“意义”*/ /*对于两个：datapacket_wrapper_t *pkt = (datapacket_wrapper_t *)buffer； uint8_t *byteBuf = (uint8_t *)buffer; 我们可以创建任意多个、任意类型的指针,无论我们使用哪个指针去修改这块内存,我们改变的都是那块唯一的、客观存在的物理内存区域,因此，当我们换一个指针去查看这块内存时，看到的就是被其他指针修改后的最新状态 */ uint32_t crc = 0; for (uint32_t i = 0; i \u0026lt; data_offset + data_size; ++i) { crc += byteBuf[i]; } // 添加 CRC 到数据末尾 memcpy(byteBuf + data_offset + data_size, \u0026amp;crc, sizeof(uint32_t)); //取出crc的内容，填到校验码的地方 return totalLen; } ","date":"24 September 2025","externalUrl":null,"permalink":"/posts/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81/","section":"Posts","summary":"在这里写下您的文章摘要\u0026hellip;","title":"数据包发送","type":"posts"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"","date":"15 September 2025","externalUrl":null,"permalink":"/tags/recursion/","section":"Tags","summary":"","title":"Recursion","type":"tags"},{"content":"B 站“灵茶山艾府“的解释\n递归的核心思想：不是人肉压栈，而是“甩锅”\r#\r初学者的困境：人肉模拟调用栈\n当递归层数很少时，比如三层，你还能模拟：main 调用 A，A 调用 B，B 调用 C。C 返回给 B，B 返回给 A，A 返回给 main。但当层数一多，你的大脑就会像计算机内存溢出一样，难以追踪。\n正确的递归思维方式是“信任”或者叫“信念之跃”（Leap of Faith）。\n你只需要关注两件事：\n1.终止条件（Base Case）：什么时候问题小到可以直接解决，不需要再“甩锅”给下一层了？\n2.递归关系（Recursive Relation）：如何把当前问题，分解成一个或多个规模更小的同类子问题，并假设（信任）下一层调用能完美解决这些子问题。然后，你只需要思考如何利用子问题的解来组合成当前问题的解。\n**你不需要去想下一层是怎么实现的，你只要相信它能给你正确的结果就行了。**就像调用一个库函数sort()，你不会去关心它内部是快排还是归并.\n把递归函数本身，也当成一个黑盒的、可信赖的库函数来调用。\n以二叉树为例\r#\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // 定义二叉树节点 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; /* 我们来定义函数 maxDepth(root) 它的功能是：接收一个树的根节点，返回这棵树的最大深度。 */ int maxDepth(TreeNode* root) { // 1. 终止条件 (Base Case) // 如果这个节点是空的（比如一个叶子节点的子节点）， // 那么它构成的树深度就是 0。这是最简单、可以直接回答的问题。 if (root == nullptr) { return 0; } // 2. 递归关系 (Recursive Relation) // 对于任何一个非空的节点 root，它的最大深度是多少？ // 我们可以把它分解成两个子问题： // - 左子树的最大深度是多少？ // - 右子树的最大深度是多少？ // 这两个子问题的规模都比当前问题（整棵树的深度）要小。 // 而且它们是同类问题：都是“计算一棵树的最大深度”。 // 所以，我们可以“甩锅”了！ // 我假设 maxDepth() 这个函数已经能完美工作了（信念之跃）。 // 我把它当成一个已知的、可靠的工具来调用。 // 我“相信”下面这行代码能正确计算出左子树的深度。 // 我不去想 aleftDepth 是怎么一步步算出来的。 int leftDepth = maxDepth(root-\u0026gt;left); // 我同样“相信”这行代码能正确计算出右子树的深度。 int rightDepth = maxDepth(root-\u0026gt;right); // 3. 组合子问题的解 // 现在，我已经拿到了两个子问题的答案：leftDepth 和 rightDepth。 // 如何用这两个答案来解决我当前的问题（以 root 为根的树的深度）？ // 很显然，整棵树的深度 = 左右子树深度的较大者 + 1 (当前这一层) return std::max(leftDepth, rightDepth) + 1; } int main() { /* 构造一棵树: 3 / \\ 9 20 / \\ 15 7 */ TreeNode* root = new TreeNode(3); root-\u0026gt;left = new TreeNode(9); root-\u0026gt;right = new TreeNode(20); root-\u0026gt;right-\u0026gt;left = new TreeNode(15); root-\u0026gt;right-\u0026gt;right = new TreeNode(7); std::cout \u0026lt;\u0026lt; \u0026#34;这棵树的最大深度是: \u0026#34; \u0026lt;\u0026lt; maxDepth(root) \u0026lt;\u0026lt; std::endl; // 应该输出 3 delete root-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;right; delete root-\u0026gt;right; delete root; return 0; } 如何正确思考 maxDepth(root) 的过程？\n1.我的目标：实现 maxDepth(root) 函数。\n2.第一步：找终止条件。 什么情况下最简单？树是空的！if (root == nullptr)，深度就是 0。搞定。\n3.第二步：找递归关系。 如果树不空，root 指向一个节点。这棵树的深度和它的左右孩子有什么关系？\n左子树的深度。\n右子树的深度。\n整棵树的深度就是 max(左深度, 右深度) + 1。\n4.第三步：写代码（信念之跃）。 如何获取左子树的深度？直接调用maxDepth(root-\u0026gt;left)。相信它！ 不要去想它内部是怎么对 root-\u0026gt;left 的子节点进行递归的。就把它当成 int leftDepth = getLeftDepth() 这么一个普通的函数调用。\n如何获取右子树的深度？同理，调用 maxDepth(root-\u0026gt;right)。相信它！\n拿到 leftDepth 和 rightDepth 后，根据第二步的分析，return std::max(leftDepth, rightDepth) + 1;。\n整个思考过程，我们只关注“当前层”的逻辑。 我们把对子树的处理完全委托给了递归调用，我们是“管理者”，不是“微观执行者”。\n再举一例：二叉树的前序遍历\r#\r前序遍历的顺序是：根 -\u0026gt; 左 -\u0026gt; 右。这个定义本身就充满了递归的味道\nvoid preOrderTraversal(TreeNode* root) { // 1. 终止条件 if (root == nullptr) { return; // 空树就直接返回，什么也不做 } // 2. 处理当前节点 (根) std::cout \u0026lt;\u0026lt; root-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 访问根节点 // 3. 递归处理左子树 (左) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个左子树 preOrderTraversal(root-\u0026gt;left); // 4. 递归处理右子树 (右) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个右子树 preOrderTraversal(root-\u0026gt;right); } 正确思考 preOrderTraversal：\n1.我的目标：按“根-左-右”的顺序打印树。\n2.终止条件：root 是 nullptr，没什么可打印的，直接 return。\n3.当前层的逻辑：如果 root 不是 nullptr，根据“根-左-右”的定义，我应该：\n先处理“根”：cout \u0026lt;\u0026lt; root-\u0026gt;val;\n然后处理“左”：怎么处理？这是一个规模更小的同类问题，直接调用 preOrderTraversal(root-\u0026gt;left); 来搞定整个左子树。相信它能行！\n最后处理“右”：同理，调用 preOrderTraversal(root-\u0026gt;right); 来搞定整个右子树。相信它也能行！\n代码和逻辑完全一一对应，清晰明了。 你根本不需要去想，调用 preOrderTraversal(root-\u0026gt;left)之后，它又会怎么打印，怎么调用它的左孩子和右孩子。你只要相信这个函数的功能定义是正确的，你调用它，它就能完成任务。\n总结与建议\r#\r明确函数定义：在写递归函数之前，用一句话清晰地描述这个函数的功能。例如：“maxDepth(node)的功能是返回以 node 为根的子树的最大深度”。在后续的递归调用中，始终坚信你调用的就是这个已经实现的功能。\n只考虑当前层：你的所有逻辑都应该只围绕“当前节点”展开。你需要做什么？你需要从子问题的解中得到什么信息？你如何利用这些信息？\n找到终止条件：思考什么情况下问题规模最小，可以被直接解决，不再需要递归。这是递归的出口，没有它就会无限循环，导致“栈溢出”。\n信任递归调用：这是最关键的一步。当你对 function(sub_problem) 进行调用时，就把它当成一个已知的、正确的黑盒。你的任务不是去追踪它的执行，而是去使用它的返回结果。\n当你下次再遇到一个递归问题时，请抑制住你的大脑去模拟整个调用栈的冲动。强迫自己用上面的思维模式去思考，多练习几次，你会发现递归问题会变得异常清晰和简单。它是一种将复杂问题分解为简单、重复单元的强大思维工具。\n1. 基础遍历类 (Basic Traversal)\r#\r这类问题的核心是“访问”到每一个节点并执行简单操作，递归函数本身通常没有返回值（void）或者返回一个包含所有节点值的列表。\n核心思路： 定义一个 traverse(node) 函数，在函数内部先处理当前节点，然后递归调用 traverse(node-\u0026gt;left) 和 traverse(node-\u0026gt;right)。根据处理当前节点的时机不同，分为前、中、后序遍历。\n经典题目:\n144. 二叉树的前序遍历\r#\rclass Solution { public: void perorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; res.push_back(root-\u0026gt;val); perorder(root-\u0026gt;left, res); perorder(root-\u0026gt;right, res); } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; perorder(root, res); return res; } }; 94. 二叉树的中序遍历\r#\rclass Solution { public: void inorder(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;res) { if (node == nullptr) return; inorder(node-\u0026gt;left, res); res.push_back(node-\u0026gt;val); inorder(node-\u0026gt;right, res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; inorder(root, res); return res; } }; 145. 二叉树的后序遍历\r#\rclass Solution { public: void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; postorder(root-\u0026gt;left, res); postorder(root-\u0026gt;right, res); res.push_back(root-\u0026gt;val); } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; postorder(root, res); return res; } }; 2. 分治 / 自下而上信息汇总 (Divide and Conquer / Bottom-up)\r#\r这是最最常见的一类递归问题。你相信递归函数能帮你解决子问题，然后你只需要思考如何利用子问题的解来解决当前问题。\n核心思路 ： “我不知道怎么解决整棵树的问题，但我假设 solve(root-\u0026gt;left) 和 solve(root-\u0026gt;right) 已经帮我解决了左右子树的问题并返回了正确的结果。现在，我只需要在当前 root 节点，利用这两个结果，计算出当前树的结果，然后 return 回去。”\n经典题目:\n104. 二叉树的最大深度 (我们之前讨论过的)\r#\r左子树深度 = solve(root-\u0026gt;left), 右子树深度 = solve(root-\u0026gt;right)\n当前树深度 = max(左子树深度, 右子树深度) + 1\n111. 二叉树的最小深度 (最大深度的变体，注意处理只有单边子树的情况)\r#\rint minDepth(TreeNode* root) { if (root == nullptr) return 0; int ldepth = minDepth(root-\u0026gt;left); int rdepth = minDepth(root-\u0026gt;right); if (root-\u0026gt;right == nullptr) { return ldepth+1; } if (root-\u0026gt;left == nullptr) { return rdepth+1; } return min(ldepth, rdepth) + 1; } 543. 二叉树的直径\r#\r子问题返回子树的深度。\n当前节点计算的“穿过我的直径”是 左深度 + 右深度，同时更新全局最大值。\nint landrDepth(TreeNode* root,int\u0026amp; maxdepth) { if (root == nullptr) return 0; int ldepth = landrDepth(root-\u0026gt;left,maxdepth); int rdepth = landrDepth(root-\u0026gt;right,maxdepth); int currentdepth = ldepth + rdepth; maxdepth = max(maxdepth,currentdepth); return max(ldepth,rdepth)+1; } int diameterOfBinaryTree(TreeNode* root) { int maxdepth=0; landrDepth(root,maxdepth); return maxdepth; } 110. 平衡二叉树\r#\r引入-1，蛮有意思\u0026hellip;\u0026hellip;\n子问题需要返回两个信息：子树是否平衡，以及子树的高度。\nclass Solution { public: bool isBalanced(TreeNode* root) { return dep(root)!=-1; } int dep(TreeNode* root) { if(root==nullptr){ return 0; } int ldepth = dep(root-\u0026gt;left); if(ldepth==-1){ return -1; } int rdepth = dep(root-\u0026gt;right); if(rdepth==-1){ return -1; } // chazhi = max(chazhi,abs(ldepth - rdepth)); if(abs(ldepth - rdepth)\u0026gt;1){ return -1; } return max(ldepth,rdepth)+1; } }; 236.二叉树的最近公共祖先\r#\r子问题返回在子树中是否找到了 p 或 q。\n当前节点根据左右子树的返回情况做出判断。\n把一个复杂的“寻找 LCA”问题，降维成了一个简单的“寻找 p 或 q”的问题 emmm 怪有意思\u0026hellip;\u0026hellip;\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { //如果你确定树中所有节点的值唯一（比如二叉搜索树 BST 中常常是这样），那用 root-\u0026gt;val == p-\u0026gt;val 也可以。 if (root == nullptr || root == p || root == q) { return root; } // 函数不是在“寻找祖先”，而是在“汇报发现”。这个算法巧妙地改变了子问题的定义 // 把一个复杂的“寻找LCA”问题，降维成了一个简单的“寻找p或q”的问题 TreeNode *lAncestor = lowestCommonAncestor(root-\u0026gt;left, p, q); TreeNode *rAncestor = lowestCommonAncestor(root-\u0026gt;right, p, q); if (lAncestor ==nullptr\u0026amp;\u0026amp;rAncestor==nullptr) return nullptr; if (lAncestor != nullptr \u0026amp;\u0026amp; rAncestor != nullptr) return root; if (lAncestor == nullptr \u0026amp;\u0026amp; rAncestor != nullptr) return rAncestor; return lAncestor; } 3. 路径问题 / 自上而下信息传递 (Path Problems / Top-down)\r#\r这类问题与上一类相反，子问题的解决需要依赖其父节点的信息。因此，你需要通过递归函数的参数将信息自上而下地传递下去。\n核心思路： “我需要定义一个 solve(node, state) 函数，其中 state 是从根节点到我父节点为止积累的状态。在函数内部，我根据 state 和当前node 的值计算出新的状态 new_state，然后把它传递给我的子节点solve(node-\u0026gt;left, new_state)和 solve(node-\u0026gt;right, new_state)。”\n经典题目:\n112. 路径总和\r#\r向下传递 targetSum - node-\u0026gt;val。\n注意代码中的targetSum是值传递，也就是说并不影响函数内部操作中对其值的修改，同一层执行完res1再res2,里面传入的targetSum是相同的。\nbool hasPathSum(TreeNode *root, int targetSum) { if (root == nullptr) return 0; targetSum -= root-\u0026gt;val; if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return targetSum == 0; bool res1 = hasPathSum(root-\u0026gt;left, targetSum); bool res2 = hasPathSum(root-\u0026gt;right, targetSum); return res1 || res2; } 129. 求根节点到叶节点数字之和\r#\r向下传递 currentSum * 10 + node-\u0026gt;val。\n辅助函数并没有返回值，而是把值存在了常量里面。因为返回的不是结果，所以不用只是子问题的答案，可以是最终结果 totalsum。\nclass Solution { public: int totalsum = 0; void traverse(TreeNode* node, int currentnum) { if (node == nullptr) return; int parentnum = currentnum * 10 + node-\u0026gt;val; if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr) { totalsum = totalsum + parentnum; return; } traverse(node-\u0026gt;left, parentnum); traverse(node-\u0026gt;right, parentnum); } int sumNumbers(TreeNode* root) { traverse(root, 0); return totalsum; } }; 257. 二叉树的所有路径 #\r向下传递当前路径的字符串 currentPath + \u0026quot;-\u0026gt;\u0026quot; + node-\u0026gt;val。\nclass Solution { public: vector\u0026lt;string\u0026gt; ans; void getpath(TreeNode* root, string path) { if (root == nullptr) { return; } path = path+to_string(root-\u0026gt;val); if (root-\u0026gt;right == nullptr \u0026amp;\u0026amp; root-\u0026gt;left == nullptr) { ans.push_back(path); return; } path = path+\u0026#34;-\u0026gt;\u0026#34;; getpath(root-\u0026gt;right, path); getpath(root-\u0026gt;left, path); } vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) { getpath(root, \u0026#34;\u0026#34;); return ans; } }; 优化方案：使用回溯（Backtracking）避免浪费 还不太会，放放吧⏳\n路径用 string\u0026amp; path 传引用，递归中添加/移除（pop_back），结果直接 push 到共享 res\n无临时向量创建/合并; 字符串修改就地（O(1) 添加/移除）; 空间：O(log n) 递归栈 + O(n _ L) 最终 res; 时间：O(n _ L) 但常数小，无拷贝。 class Solution { public: void getpath(TreeNode* node, string\u0026amp; path, vector\u0026lt;string\u0026gt;\u0026amp; res) { if (node == nullptr) return; // 添加当前值（记录长度以便回溯） int prev_len = path.size(); path += to_string(node-\u0026gt;val); if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr) { res.push_back(path); // 直接 push 当前路径 } else { path += \u0026#34;-\u0026gt;\u0026#34;; // 添加箭头 getpath(node-\u0026gt;left, path, res); getpath(node-\u0026gt;right, path, res); path.resize(path.size() - 2); // 移除 \u0026#34;-\u0026gt;\u0026#34; } path.resize(prev_len); // 移除当前值（回溯） } vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) { vector\u0026lt;string\u0026gt; res; string path = \u0026#34;\u0026#34;; getpath(root, path, res); return res; } }; 113. 路径总和 II (路径总和的升级版) #\r向下传递当前路径的节点列表 vector\u0026lt;int\u0026gt; currentPath。\nclass Solution { public: vector\u0026lt;int\u0026gt; path; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; void cacula(TreeNode* root, int currentnum) { if(root==nullptr){ return; } path.push_back(root-\u0026gt;val); currentnum = currentnum - root-\u0026gt;val; if (root-\u0026gt;right == nullptr \u0026amp;\u0026amp; root-\u0026gt;left == nullptr) { if (currentnum == 0) { ans.push_back(path); path.pop_back(); return; } path.pop_back(); return; } cacula(root-\u0026gt;left, currentnum); cacula(root-\u0026gt;right, currentnum); path.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int targetSum) { if(root==nullptr) { return ans; } cacula(root, targetSum); return ans; } }; 124. 二叉树中的最大路径和\r#\r辅助函数的主要功能是求解单边最大，这样计算左右两边最大就可以得到想要的最大值。 不要拘泥于辅助函数必须返回目标值，这种直接得到目标值行不通的，可以考虑分解目标，但是将目标值存储在变量中。\nint globalmax = numeric_limits\u0026lt;int\u0026gt;::min(); int cacule2(TreeNode \\*root) { if (root == nullptr) return 0; int lmax = max(0,cacule2(root-\u0026gt;left)); int rmax = max(0,cacule2(root-\u0026gt;right)); int currentnum = root-\u0026gt;val + lmax + rmax; globalmax = max(currentnum, globalmax); return root-\u0026gt;val+max(lmax,rmax); } int maxPathSum(TreeNode \\*root) { globalmax = numeric_limits\u0026lt;int\u0026gt;::min(); cacule2(root); return globalmax; } 4. 结构比较与修改 (Structural Comparison \u0026amp; Modification)\r#\r这类问题通常涉及两棵树，或者需要翻转、修改树的结构。\n核心思路：\n递归函数通常同时作用于两棵树的对应节点，或者在修改完当前节点的结构后，再对子节点进行递归调用。\n经典题目:\n100. 相同的树 #\risSameTree(p, q) 依赖于 isSameTree(p-\u0026gt;left, q-\u0026gt;left) 和 isSameTree(p-\u0026gt;right, q-\u0026gt;right) 的结果。\nclass Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p==nullptr\u0026amp;\u0026amp;q==nullptr){ return true; } if((p==nullptr\u0026amp;\u0026amp;q!=nullptr)||(p!=nullptr\u0026amp;\u0026amp;q==nullptr)||p-\u0026gt;val!=q-\u0026gt;val) { return false; } bool isLeftSame = isSameTree(p-\u0026gt;left,q-\u0026gt;left); bool isRightSame = isSameTree(p-\u0026gt;right,q-\u0026gt;right); return isLeftSame\u0026amp;\u0026amp;isRightSame; } }; 101. 对称二叉树 #\r这是判断两棵树是否镜像对称的变体。递归函数 isMirror(p, q) 依赖于 isMirror(p-\u0026gt;left, q-\u0026gt;right) 和 isMirror(p-\u0026gt;right, q-\u0026gt;left)。\nclass Solution { public: bool isMirror(TreeNode* p, TreeNode* q) { if (p == nullptr \u0026amp;\u0026amp; q == nullptr) { return true; } if ((p == nullptr \u0026amp;\u0026amp; q != nullptr) || (p != nullptr \u0026amp;\u0026amp; q == nullptr) || (p-\u0026gt;val != q-\u0026gt;val)) { return false; } bool isSameOuter = isMirror(p-\u0026gt;left, q-\u0026gt;right); bool isSameInner = isMirror(p-\u0026gt;right, q-\u0026gt;left); return isSameOuter \u0026amp;\u0026amp; isSameInner; } bool isSymmetric(TreeNode* root) { if (root == nullptr) { return true; } return isMirror(root-\u0026gt;left, root-\u0026gt;right ); } 226. 翻转二叉树 #\r在当前节点交换左右子节点，然后递归调用 invertTree(root-\u0026gt;left) 和 invertTree(root-\u0026gt;right)。\nclass Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) return nullptr; TreeNode* left = invertTree(root-\u0026gt;left); TreeNode* right = invertTree(root-\u0026gt;right); root-\u0026gt;right = left; root-\u0026gt;left = right; return root; } }; 总结与练习建议\r#\r题号 题目 核心思路 类 别 状态 94, 144, 145 二叉树遍历 访问所有节点 基础遍历 ✅ 104, 111 树的深度 从子树获取深度，组合成当前深度 分治 / 自下而上 ✅ 543 二叉树的直径 从子树获取深度，计算穿过当前节点的直径 分治 / 自下而上 ✅ 110 平衡二叉树 从子树获取“是否平衡”和“深度”两个信息 分治 / 自下而上 ✅ 236 最近公共祖先 从子树获取是否包含目标节点的信息 分治 / 自下而上 ✅ 112, 113 路径总和 将目标和减去当前值，向下传递 路径 / 自上而下 ✅ 129 求根到叶节点数字之和 将当前路径和乘以 10 加上当前值，向下传递 路径 / 自上而下 ✅ 257 二叉树的所有路径 将当前路径字符串拼接上当前值，向下传递 路径 / 自上而下 ✅ 100 相同的树 同时递归比较两棵树的对应子树 结构比较 ✅ 101 对称二叉树 同时递归比较一棵树的内外侧子树 结构比较 ✅ 226 翻转二叉树 交换当前节点的左右子节点，然后递归翻转子树 结构修改 ✅ 如何练习：\n从基础遍历开始，确保你理解前、中、后序的区别。\n主攻“分治 / 自下而上”，这是最重要的递归模式。以“最大深度”为模板，彻底理解“信任”递归调用的思想。\n然后练习“路径 / 自上而下”，理解通过参数传递状态的方法。\n最后解决结构类问题，它们通常是前面几种思想的结合或变体。\n几乎所有二叉树问题都能被归入这几类。当你遇到一个新问题时，先思考一下：“解决这个问题，我需要从子树获得什么信息，还是需要向子树传递什么信息？” 这能帮助你快速确定递归的结构。\n是否需要返回值问题\r#\r如果叶节点或中间节点需要“向上报告”信息（如子树结果），用返回值 如果只是“遍历 + 收集到外部容器”，用 void + 共享状态\n更多练习题目：\r#\r108. 将有序数组转换为二叉搜索树 #\rclass Solution { public: TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return help(nums,0,nums.size()-1); } TreeNode* help(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt; right) { //左右相同的下一步就是左边大于右边，左右相同得放进树里面 return nullptr; } int mid = (left + right + 1) / 2; TreeNode* root = new TreeNode(nums[mid]); root-\u0026gt;left = help(nums, left, mid - 1); root-\u0026gt;right = help(nums, mid + 1, right); return root; } }; 98. 验证二叉搜索树 #\r方案 1：中序遍历（推荐的简洁方法） 核心原理： 对一个二叉搜索树（BST）进行中序遍历（左 → 根 → 右），得到的节点值序列一定是严格递增的。\nclass Solution { private: // 必须用成员变量或引用参数来维护这个状态 long long prevVal = LLONG_MIN; public: bool isValidBST(TreeNode* root) { if (root == nullptr) { return true; } // 1. 递归检查左子树 if (!isValidBST(root-\u0026gt;left)) { return false; } // 2. 检查当前节点（中序遍历的核心逻辑） // 核心：当前值必须严格大于上一个值 if (root-\u0026gt;val \u0026lt;= prevVal) { return false; } // 3. 更新上一个值 prevVal = root-\u0026gt;val; // 4. 递归检查右子树 return isValidBST(root-\u0026gt;right); } }; 方案 2：上下限递归（更基础的方法）\nclass Solution { public: bool isValidBST(TreeNode* root) { return helper(root,LLONG_MIN,LLONG_MAX); } bool helper(TreeNode* root, long long lower, long long upper) { if (root == nullptr) return true; if (root-\u0026gt;val \u0026lt;= lower || root-\u0026gt;val \u0026gt;= upper) return false; bool left = helper(root-\u0026gt;left, lower, root-\u0026gt;val); bool right = helper(root-\u0026gt;right, root-\u0026gt;val, upper); return left \u0026amp;\u0026amp; right; } }; 230. 二叉搜索树中第 K 小的元素 #\rclass Solution { public: int kthSmallest(TreeNode* root, int k) { vector\u0026lt;int\u0026gt; result; helper(root,result); return result[k-1]; } void helper(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; helper(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); helper(root-\u0026gt;right,res); } }; 使用布尔信号提前终止\nclass Solution { public: int kthSmallest(TreeNode* root, int k) { vector\u0026lt;int\u0026gt; result; helper(root, result, k); return result[k - 1]; } bool helper(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res, int n) { // 递归终止条件 1: 节点为空，返回 false (继续遍历) if (root == nullptr) return false; // 递归终止条件 2: 已经找到 K 个元素，直接返回 true (停止) if (res.size() == n) { return true; } if (helper(root-\u0026gt;left, res, n)) return true; res.push_back(root-\u0026gt;val); if (res.size() == n) { return true; } return helper(root-\u0026gt;right, res, n); } }; 114. 二叉树展开为链表 #\r方法一：普通方法（递归）\nclass Solution { public: void flatten(TreeNode* root) { vector\u0026lt;TreeNode*\u0026gt; res; help(root, res); int n = res.size(); for (int i = 0; i \u0026lt; n-1; i++) { TreeNode* node = res[i]; node-\u0026gt;left =nullptr; node-\u0026gt;right = res[i+1]; } } void help(TreeNode* root, vector\u0026lt;TreeNode*\u0026gt;\u0026amp; res) { if (root != nullptr) { res.push_back(root); help(root-\u0026gt;left, res); help(root-\u0026gt;right, res); } } }; 方法二：递归/逆向先序遍历 (Right → Left → Root)\nclass Solution { public: void flatten(TreeNode* root) { help(root); } TreeNode* pre = nullptr; void help(TreeNode* root) { if (root == nullptr) { return; } help(root-\u0026gt;right); help(root-\u0026gt;left); root-\u0026gt;right = pre; root-\u0026gt;left = nullptr; pre = root; return; } }; 方法三：迭代 + 寻找前驱 (Morris Traversal 思想) //看不懂思密达\nclass Solution { public: void flatten(TreeNode* root) { TreeNode* curr = root; while (curr != nullptr) { // 1. 如果有左子树 if (curr-\u0026gt;left != nullptr) { // 2. 找到左子树的最右节点 (前驱 predecessor) TreeNode* predecessor = curr-\u0026gt;left; while (predecessor-\u0026gt;right != nullptr) { predecessor = predecessor-\u0026gt;right; } // 3. 关键连接：将右子树接在左子树的末尾 predecessor-\u0026gt;right = curr-\u0026gt;right; // 4. 重排：将左子树整体搬到右侧 curr-\u0026gt;right = curr-\u0026gt;left; curr-\u0026gt;left = nullptr; // 清空左指针 } // 5. 前进到下一个节点（即原先的右子树或新的右子树的根） curr = curr-\u0026gt;right; } } }; ","date":"15 September 2025","externalUrl":null,"permalink":"/notes/recursive_relation/","section":"Notes","summary":"","title":"递归基础及题目（Recursive Relation）","type":"notes"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/conda/","section":"Tags","summary":"","title":"Conda","type":"tags"},{"content":"https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html\n创建环境\r#\r创建一个新环境\nconda create -n \u0026lt;env-name\u0026gt; 创建环境并且下载指定包\nconda create -n myenvironment python numpy pandas\rconda create -n myenv scipy=0.17.3 //特定库版本 创建环境指定特定pyhton版本 conda create -n myenv python=3.9 conda create -n myenv python=3.9 特定pyhton版本和多个库 conda create -n myenv python=3.9 scipy=0.17.3 astroid babel\n查看所有环境\r#\rconda info --envs\r例如：\rconda environments:\rbase /home/username/Anaconda3\rmyenvironment * /home/username/Anaconda3/envs/myenvironment 当前环境带*\n改变当前环境为默认的一个\nconda activate 下载库\r#\r# via environment activation\rconda activate myenvironment\rconda install matplotlib\r# via command line option\rconda install --name myenvironment matplotlib If a package you want is located in another channel, such as conda-forge, you can manually specify the channel when installing the package:\nconda install conda-forge::numpy 更新Conda\r#\r查看Conda版本\nconda --version 更新到最新版本\nconda update conda ","date":"8 September 2025","externalUrl":null,"permalink":"/posts/conda_start/","section":"Posts","summary":"Conda使用","title":"Conda Start","type":"posts"},{"content":"\r莫里斯遍历 - 实例走查\r#\r我们将使用下面的树来进行中序遍历。遍历的结果应该是 [1, 2, 3, 4, 6]。\n初始状态:\ncurrent 指向根节点 4。 result (结果数组) 为 []。 4 \u0026lt;\u0026ndash; current / \\ 2 6 /\\ 1 3\n第 1 步\r#\rcurrent = 4\n判断: current (4) 有左孩子 2。\n动作:\n找到 current (4) 的左子树 (2 为根) 的最右节点。这个节点是 3。 3 的右指针是 nullptr。 建立线索: 将 3 的右指针指向 current (4)。 current 向左移动：current = current-\u0026gt;left (移向 2)。 树的状态: 4 / \\ 2 6 / 1 3 \u0026ndash;+ ^ | |___| (线索指向 4)\nresult: []\n第 2 步\r#\rcurrent = 2\n判断: current (2) 有左孩子 1。\n动作:\n找到 current (2) 的左子树 (1 为根) 的最右节点。这个节点就是 1 本身。 1 的右指针是 nullptr。 建立线索: 将 1 的右指针指向 current (2)。 current 向左移动：current = current-\u0026gt;left (移向 1)。 树的状态: 4 / 2 6 /\n1 3 \u0026ndash;+ ^ \\ | | +\u0026mdash;-|\u0026ndash;(线索指向 2) |_______| (线索指向 4)\nresult: [] 第 3 步\r#\rcurrent = 1\n判断: current (1) 没有左孩子。\n动作:\n访问 1。 current 向右移动：current = current-\u0026gt;right (根据我们建立的线索，它会移向 2)。 result: [1]\n第 4 步\r#\rcurrent = 2\n判断: current (2) 有左孩子 1。\n动作:\n再次找到 current (2) 的左子树的最右节点，还是 1。 这一次，我们发现 1 的右指针指向 current (2)，说明我们已经处理完 current 的左子树了。 访问 2。 断开线索: 将 1 的右指针恢复为 nullptr。 current 向右移动：current = current-\u0026gt;right (移向 3)。 树的状态 (1-\u0026gt;2 的线索已断开): 4 / \\ 2 6 / 1 3 \u0026ndash;+ ^ | |___| (线索指向 4)\nresult: [1, 2]\n第 5 步\r#\rcurrent = 3\n判断: current (3) 没有左孩子。\n动作:\n访问 3。 current 向右移动：current = current-\u0026gt;right (根据我们建立的线索，它会移向 4)。 result: [1, 2, 3]\n第 6 步\r#\rcurrent = 4\n判断: current (4) 有左孩子 2。\n动作:\n再次找到 current (4) 的左子树的最右节点，还是 3。 我们发现 3 的右指针指向 current (4)，说明我们已经处理完 current 的左子树了。 访问 4。 断开线索: 将 3 的右指针恢复为 nullptr。 current 向右移动：current = current-\u0026gt;right (移向 6)。 树的状态 (完全恢复): 4 / \\ 2 6 / 1 3\nresult: [1, 2, 3, 4]\n第 7 步\r#\rcurrent = 6\n判断: current (6) 没有左孩子。\n动作:\n访问 6。 current 向右移动：current = current-\u0026gt;right (移向 nullptr)。 result: [1, 2, 3, 4, 6]\n结束\r#\rcurrent = nullptr 判断: 循环结束。 最终，我们得到了正确的中序遍历结果 [1, 2, 3, 4, 6]，并且树的结构也完全恢复到了初始状态。\n希望这个一步步的分解能帮助你理解莫里斯遍历的工作流程！\n","date":"3 September 2025","externalUrl":null,"permalink":"/notes/morris_traversal/","section":"Notes","summary":"","title":"Morris Traversal","type":"notes"},{"content":"步骤 1: 在 GitHub 上创建新的远程仓库 步骤 2: 在本地电脑上操作\n# 打开 Git Bash进入你的项目文件夹\rcd ~/Desktop/my-first-project\r# 初始化 Git 仓库:\rgit init\r#添加所有文件到暂存区:\rgit add .\r# 提交文件到本地仓库:\rgit commit -m \u0026#34;Initial commit\u0026#34;\r#重命名主分支为 main\rgit branch -m main\r# 关联本地仓库和远程仓库:\rgit remote add origin https://github.com/YourUsername/YourProjectName.git # 把下面的 URL 换成你自己的仓库 URL\r# 推送代码到 GitHub:\rgit push -u origin main ","date":"2 September 2025","externalUrl":null,"permalink":"/posts/a_folder_to_git/","section":"Posts","summary":"本地文件夹上传至GitHub","title":"A Folder to Git","type":"posts"},{"content":"创建项目文件夹\n打开命令行工具（比如 CMD、PowerShell 或者 Windows Terminal），然后进入存放所有代码的目录（例如 D:\\projects）。\n# 1. 进入项目的父目录(请根据实际情况修改 \u0026#34;D:\\projects\u0026#34;)\rcd D:\\projects\r2. 创建新文件夹作为根目录\rmkdir my_new_project\r3. 进入这个新创建的文件夹\rcd my_new_project 创建虚拟环境\n# 确保在项目根目录下 (D:\\projects\\my_new_project)\r# -m venv 的意思是 \u0026#34;以模块(module)方式运行 venv\u0026#34;\r# 最后的 \u0026#34;venv\u0026#34; 是给虚拟环境文件夹取的名字\rpython -m venv venv\r# 执行完毕后，会发现项目文件夹里多出了一个名为 venv 的子文件夹。这里面包含了独立的 Python 解释器和未来将要安装的库。 激活虚拟环境\n# 在 Windows PowerShell 中，运行以下命令\r.\\venv\\Scripts\\activate 激活成功后，会看到命令行提示符的前面多了一个 (venv) 的标记，像这样：\r(venv) PS D:\\projects\\my_new_project\u0026gt; 这个 (venv) 标志非常重要，它告诉你当前终端已经处于激活的虚拟环境中。所有后续的 pip 安装和 python 命令都将只在这个环境内生效。\n# 在 VS Code 中打开项目,确保还在项目根目录下 (有 (venv) 标志),这个命令会用 VS Code 打开当前文件夹\rcode . 配置 VS Code 解释器\n1.当用 VS Code 打开带有 venv 文件夹的项目时，VS Code 通常会在右下角弹出一个提示：We noticed a new environment has been created. Do you want to select it for the workspace folder? (我们发现了一个新环境，您要为工作区选择它吗？)。\n请务必点击 Yes。\n2.如果 VS Code 没有自动提示，可以手动选择：\n按下 Ctrl+Shift+P 打开命令面板。\n输入并选择 Python: Select Interpreter (Python: 选择解释器)。\n在列表中，选择那个带有 (\u0026lsquo;venv\u0026rsquo;: venv) 标志或者路径中包含 .\\venv\\Scripts\\python.exe 的选项。\n安装项目所需的库\n现在，可以在 VS Code 的集成终端中（确保终端前面有 (venv) 标志）安装任何需要的第三方库了。\n完整的、专业的开发流程\n在项目开始时就创建.gitignore 文件，并加入 venv/\n在虚拟环境中安装项目所需的库（例如pip install pandas）\n每当安装或更新了重要的库之后，就更新 requirements.txt文件： pip freeze \u0026gt; requirements.txt\n将源代码、.gitignore 和更新后的 requirements.txt 一起提交到GitHub。\ngit add .\rgit commit -m \u0026#34;Add new feature and update dependencies\u0026#34;\rgit push 拿到项目后,只需要执行以下几步\n克隆仓库 git clone \u0026lt;your_repo_url\u0026gt;\rcd \u0026lt;your_repo_name\u0026gt; 创建并激活他们自己的venv python -m venv venv 在Windows上:\r.\\venv\\Scripts\\activate\r在macOS/Linux上:\rsource venv/bin/activate 根据依赖列表，一键安装所有库 pip install -r requirements.txt ","date":"11 August 2025","externalUrl":null,"permalink":"/posts/create_new_project/","section":"Posts","summary":"带虚拟环境的 Python 项目","title":"Create New Project","type":"posts"},{"content":"","date":"11 August 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" 状态 图标 说明 完成 ✅ 任务已完成 进行中 🔄 正在处理 待处理 ⏳ 等待开始 错误 ❌ 出现问题 警告 ⚠️ 需要注意 未完成的任务 已完成的任务 另一个未完成的任务 特性 React Vue.js Angular 评分 学习曲线 中等 简单 复杂 Vue ⭐⭐⭐ 性能表现 优秀 优秀 良好 平分 ⭐⭐⭐ 生态系统 丰富 成长中 完整 React ⭐⭐⭐ 企业支持 Facebook 社区 Google Angular ⭐⭐⭐ 使用 Ctrl+Alt+Del 重启电脑\ngraph LR\rA[方形] --\u0026gt;B(圆角)\rB --\u0026gt; C{条件a}\rC --\u0026gt;|a=1| D[结果1]\rC --\u0026gt;|a=2| E[结果2]\rF[横向流程图] graph TD\rA[方形] --\u0026gt; B(圆角)\rB --\u0026gt; C{条件a}\rC --\u0026gt; |a=1| D[结果1]\rC --\u0026gt; |a=2| E[结果2]\rF[竖向流程图] st=\u0026gt;start: 开始框\rop=\u0026gt;operation: 处理框\rcond=\u0026gt;condition: 判断框(是或否?)\rsub1=\u0026gt;subroutine: 子流程\rio=\u0026gt;inputoutput: 输入输出框\re=\u0026gt;end: 结束框\rst(right)-\u0026gt;op(right)-\u0026gt;cond\rcond(yes)-\u0026gt;io(bottom)-\u0026gt;e\rcond(no)-\u0026gt;sub1(right)-\u0026gt;op 文本中的变量 $x = 5$ 和函数 $f(x) = x^2 + 2x + 1$。\n$$\r\\begin{align}\rf(x) \u0026= ax^2 + bx + c \\\\\rf'(x) \u0026= 2ax + b \\\\\rf''(x) \u0026= 2a\r\\end{align}\r$$$$E = mc^2$$$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$ 张三 | 前端开发工程师\r#\r📞 联系方式\r#\r邮箱: zhangsan@email.com 电话: 138-0000-0000 GitHub: github.com/zhangsan LinkedIn: linkedin.com/in/zhangsan 地址: 上海市浦东新区 🎯 职业目标\r#\r具有 3 年前端开发经验的工程师，专注于 React 生态系统和现代化 Web 应用开发。寻求在创新型公司中担任高级前端开发职位，希望参与大型项目的架构设计和团队协作。\n💼 工作经验\r#\r高级前端开发工程师 | ABC 科技有限公司\r#\r2022.03 - 至今\n负责公司核心产品的前端开发，用户量达 100 万+ 使用 React、TypeScript 构建可维护的大型单页应用 与产品和设计团队协作，将设计稿转化为高质量的用户界面 建立前端组件库，提升团队开发效率 30% 技术栈: React, TypeScript, Redux, Webpack, Jest 前端开发工程师 | XYZ 互联网公司\r#\r2021.06 - 2022.02\n参与电商平台的前端开发和维护工作 优化页面性能，首屏加载时间减少 40% 负责移动端 H5 页面开发，适配多种设备 技术栈: Vue.js, JavaScript, SCSS, Element UI 🛠️ 技能清单\r#\r编程语言\r#\r熟练: JavaScript, TypeScript, HTML5, CSS3 了解: Python, Java, Go 前端框架\r#\rReact 生态: React, Redux, React Router, Next.js Vue 生态: Vue.js, Vuex, Vue Router, Nuxt.js 其他: Angular 基础 开发工具\r#\r版本控制\r#\rGit, GitHub, GitLab 构建工具\r#\rWebpack, Vite, Rollup Babel, PostCSS 测试工具\r#\rJest, Cypress, Testing Library 📱 联系方式\r#\r💼 工作经验\r#\r🎓 教育背景\r#\r🛠️ 技能清单\r#\r🚀 项目经历\r#\r🏆 获奖经历\r#\r📊 技能评估\r#\r技能类别 具体技能 熟练程度 前端框架 React ⭐⭐⭐⭐⭐ 前端框架 Vue.js ⭐⭐⭐⭐ 编程语言 TypeScript ⭐⭐⭐⭐ 编程语言 JavaScript ⭐⭐⭐⭐⭐ 🔗 在线作品\r#\r","date":"9 August 2025","externalUrl":null,"permalink":"/posts/learnmd/","section":"Posts","summary":"","title":"Publishing_process 博客发布流程","type":"posts"},{"content":"1.创建一篇新文章 打开Git Bash 终端，进入根目录d:/Blog\nhugo new content posts/hello-world.md\n告诉Hugo，在 content/posts/ 目录下，创建一个名为 hello-world.md 的新文章。\n2.编写文章内容\n打开VS Code，在 hello-world.md里面写内容 将draft：true改为draft：false 3.在本地预览效果\n回到Git Bash终端，运行： hugo server\n终端会启动一个本地服务器，并显示网址 http://localhost:1313/,打开网址浏览即可 预览完毕后，回到终端，按 Ctrl + C 组合键，停止本地服务器。 4.提交并推送到GitHub (自动发布)\n添加更改到暂存区 git add .\n提交更改到本地仓库 (创建一个新的提交记录) git commit -m \u0026ldquo;feat: Add my first post \u0026lsquo;Hello World\u0026rsquo;\u0026rdquo;\nfeat: 是一种规范的提交信息前缀，意思是“增加新功能”，这里指增加了新文章。\n写了一篇新文章？用 feat。\n修改了一篇文章的内容或错别字？用 docs。\n修正了一个导致网站显示不正常的Bug？用 fix。\n更新了 .gitignore 或者 deploy.yml？用 chore。\n推送到GitHub (这是触发自动部署的扳机) git push origin main\n5.检查线上部署\n打开浏览器，进入您之前创建的源码仓 (Blog-Source) 的GitHub页面。 点击页面上方的 “Actions” 选项卡。 您会看到一个新的工作流（Workflow）正在运行，它前面会有一个黄色的小圆圈。这就是GitHub在后台帮您生成和部署网站。 等待1-2分钟，当黄色圆圈变成绿色的对勾 (✓) 时，就代表您的网站已经部署成功了。 现在，请在浏览器中访问您的线上博客地址： https://\u0026lt;您的GitHub用户名\u0026gt;.github.io\n","date":"9 August 2025","externalUrl":null,"permalink":"/posts/publishing_process/","section":"Posts","summary":"","title":"Publishing_process 博客发布流程","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]